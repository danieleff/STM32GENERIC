{
    "docs": [
        {
            "location": "/", 
            "text": "STM32GENERIC\n\n\nA generic \nArduino\n implementation for \nSTM32 boards\n.\n\n\nInstallation - Users\n\n\nTODO create boards manager package\n\n\nInstallation - Developers\n\n\n\n\nDownload the latest version from \nhttps://github.com/danieleff/STM32GENERIC\n\n\nUnzip it into [Arduino]/hardware folder\n\n\nInstall Arduino Zero from the board manager for the arm-none-eabi-gcc compiler\n\n\n\n\nUploading\n\n\nPlease go to the \nUploading\n page.\n\n\nList of boards\n\n\nPlease go to the \nBoards\n page.\n\n\nAPI documentation\n\n\nPlease go to the \nArduino API implementation\n page.", 
            "title": "Installation"
        }, 
        {
            "location": "/#stm32generic", 
            "text": "A generic  Arduino  implementation for  STM32 boards .", 
            "title": "STM32GENERIC"
        }, 
        {
            "location": "/#installation-users", 
            "text": "TODO create boards manager package", 
            "title": "Installation - Users"
        }, 
        {
            "location": "/#installation-developers", 
            "text": "Download the latest version from  https://github.com/danieleff/STM32GENERIC  Unzip it into [Arduino]/hardware folder  Install Arduino Zero from the board manager for the arm-none-eabi-gcc compiler", 
            "title": "Installation - Developers"
        }, 
        {
            "location": "/#uploading", 
            "text": "Please go to the  Uploading  page.", 
            "title": "Uploading"
        }, 
        {
            "location": "/#list-of-boards", 
            "text": "Please go to the  Boards  page.", 
            "title": "List of boards"
        }, 
        {
            "location": "/#api-documentation", 
            "text": "Please go to the  Arduino API implementation  page.", 
            "title": "API documentation"
        }, 
        {
            "location": "/upload/", 
            "text": "Uploading your sketch\n\n\nSelect the upload method from the Tools / upload menu option.\n\n\n\n\n\n\n\n\nMethod\n\n\nConnection\n\n\nRequirements\n\n\n\n\n\n\n\n\n\n\nSWD / JTAG\n\n\nSWD pins\n\n\nSWD Programmer hardware, (included in Nucleo and Discovery boards)\n\n\n\n\n\n\nMass storage\n\n\nSWD pins\n\n\nST-Link V2.1, (included in Nucleo and Discovery boards)\n\n\n\n\n\n\nSystem bootloader\n\n\nUART1\n\n\nBOOT0 / BOOT1 pins accessible, USB to UART adapter\n\n\n\n\n\n\nUSB Flash bootloader\n\n\nUSB\n\n\nUSB connector, Bootloader already installed using other method\n\n\n\n\n\n\nBlack Magic Probe\n\n\nUSB\n\n\nBlack Magic Probe", 
            "title": "Uploading"
        }, 
        {
            "location": "/upload/#uploading-your-sketch", 
            "text": "Select the upload method from the Tools / upload menu option.     Method  Connection  Requirements      SWD / JTAG  SWD pins  SWD Programmer hardware, (included in Nucleo and Discovery boards)    Mass storage  SWD pins  ST-Link V2.1, (included in Nucleo and Discovery boards)    System bootloader  UART1  BOOT0 / BOOT1 pins accessible, USB to UART adapter    USB Flash bootloader  USB  USB connector, Bootloader already installed using other method    Black Magic Probe  USB  Black Magic Probe", 
            "title": "Uploading your sketch"
        }, 
        {
            "location": "/menu_options/", 
            "text": "Arduino tools menu\n\n\nThe following options can be selected in the Arduino tools menu, below the selected board:\n\n\nUpload method\n\n\nSee the \nuploading\n page.\n\n\nUSB\n\n\nThe following options are available for USB\n\n\n\n\nSerial. A Virtual COM port will be available when connected. Note: On Windows 7, you will need to install drivers located in tool/win/drivers folder.\n\n\nDisabled, no USB. Note: If you use USB based uploading method, the board will not reset automatically.\n\n\n\n\nDefault serial communication selection\n\n\nSelect the default for \nSerial\n:\n\n\nAutomatically selected:\n\n\n\n\nIf the board is Nucleo, automatic Serial is aliased to \nSerialUART2\n (ST-Link Virtual COM port).\n\n\nIf the upload method is based on UART (Serial upload, ST-Link), automatic Serial is aliased to \nSerialUART1\n.\n\n\nIf the upload method is based on USB (DFU), automatic Serial aliased to \nSerialUSB\n.\n\n\n\n\nSerialUSB\n\n\nSerialUART1", 
            "title": "Menu options"
        }, 
        {
            "location": "/menu_options/#arduino-tools-menu", 
            "text": "The following options can be selected in the Arduino tools menu, below the selected board:", 
            "title": "Arduino tools menu"
        }, 
        {
            "location": "/menu_options/#upload-method", 
            "text": "See the  uploading  page.", 
            "title": "Upload method"
        }, 
        {
            "location": "/menu_options/#usb", 
            "text": "The following options are available for USB   Serial. A Virtual COM port will be available when connected. Note: On Windows 7, you will need to install drivers located in tool/win/drivers folder.  Disabled, no USB. Note: If you use USB based uploading method, the board will not reset automatically.", 
            "title": "USB"
        }, 
        {
            "location": "/menu_options/#default-serial-communication-selection", 
            "text": "Select the default for  Serial :  Automatically selected:   If the board is Nucleo, automatic Serial is aliased to  SerialUART2  (ST-Link Virtual COM port).  If the upload method is based on UART (Serial upload, ST-Link), automatic Serial is aliased to  SerialUART1 .  If the upload method is based on USB (DFU), automatic Serial aliased to  SerialUSB .   SerialUSB  SerialUART1", 
            "title": "Default serial communication selection"
        }, 
        {
            "location": "/arduino_api/", 
            "text": "Overview\n\n\n\n\nSTM32GENERIC uses standard C and C++, so control sturctures (if, for), data types(int, long), syntax, etc... work as expected.\n\n\nNon microcontroller-specific Arduino utility functions such as isLowerCase(), bitRead() etc... also work.\n\n\nAll non-standard functions are prefixed with \nstm32XXXX()\n\n\n\n\nuint32_t millis();\n\n\nReturns the milliseconds since the microcontroller started. Overflows in 50 days.\n\n\nuint32_t micros();\n\n\nReturns the microseconds since the microcontroller started. Overflows in 70 minutes.\n\n\ndelay(uint32_t millis);\n\n\nDelays the execution by the given milliseconds.\n\n\ndelayMicroseconds(uint32_t micros);\n\n\nDelays the execution by the given microseconds.\n\n\n\n\nExample: Print the milliseconds on \nSerial\n, every second:\n\n\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\nvoid loop() {\n  Serial.println(millis());\n  delay(1000);\n}\n\n\n\n\n\n\nUses STM32 SysTick, set to interrupt 1ms intervals.\n\n\n\n\nNaming the pins in code:\n\n\n\n\nSTM32 chip pins have names: \nPA0\n, \nPA1\n...\n\n\nOn some boards (Nucleo, Maple), there are numbers / alternative names next to the pin: \n1\n, \nRX\n, \nA0\n.\n\n\nPredefined constants\n for primary LED, SPI, Serial, I2C are defined in the variant file for the specific board.\n\n\n\n\nGenerally you should stick to naming the pin the same as they appear on the board to reduce confusion. If on the board you see ABC, use digitalWrite(ABC, HIGH);\n\n\npinMode(uint8_t pin, uint8_t mode);\n\n\nSets the pin for digital reading / writing\n\n\n\n\n\n\n\n\nMode\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOUTPUT\n\n\n0V - 3.3V\n\n\n\n\n\n\nINPUT\n\n\nThe pin does not have a pull down or pull up resistor\n\n\n\n\n\n\nINPUT_PULLUP\n\n\nWeak pull up resistor to default to HIGH if the pin is not connected to anything\n\n\n\n\n\n\nINPUT_PULLDOWN\n\n\nWeak pull down resistor to default to LOW if the pin is not connected to anything\n\n\n\n\n\n\n\n\npinMode() is needed for digitalRead() and digitalWrite() functions.\n\n\nThe system automatically sets the pinMode when using a peripheral library like analogRead(), analogWrite(), \nSPI\n or \nI2C\n, so you don't have to.\n\n\ndigitalRead(uint8_t pin);\n\n\nRead the voltage level on the specified pin. Returns LOW(0) if it is 0V, HIGH(1) if it is 3.3V\n\n\nAll pins can be used as digital input.\n\n\nNot all pins are 5V tolerant. Please check the chip reference manual \nPinouts and pin description\n section.\n\n\ndigitalWrite(uint8_t pin, uint8_t value);\n\n\nIf value if LOW(0), sets the pin to 0V. If value is HIGH(1), 3.3V.\n\nAll pins can be used as digital output.\n\n\n\n\nExample: Blink the \nLED\n on the board:\n\n\n\n\nvoid setup() {\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n  delay(1000);\n}\n\n\n\n\nint analogRead(uint8_t pin);\n\n\nRead the voltage level on the pin, and map the 0..3.3V range to 0..1023 range by default.\n\n\nNot all pins can be used as analog input!\n Please check the \nBoards page\n.\n\n\nanalogReadResolution()\n\n\nTODO not yet implemented\n\n\nanalogWrite(uint8_t pin, int value)\n\n\nSet PWM to the specified pin.\n\n\nAll pins can be used as analog/PWM output.\n\n\n\n\nUses the TIM2 clock interrupt with software PWM implementation to allow PWM on all pins.\n\n\n\n\nanalogWriteResolution()\n\n\nTODO not yet implemented\n\n\n\n\nExample: Dim the LED based on the voltage value on PA0\n\n\n\n\nvoid loop() {\n    analogWrite(LED_BUILTIN, analogRead(PA0));\n    delay(10);\n}\n\n\n\n\nvoid attachInterrupt(uint8_t, callback, int mode);\n\n\nSetup callback on the specified pin. Mode can be: \n\n CHANGE: When pin changes from LOW to HIGH, or HIGH to LOW, the callback will be called. \n\n RISING: When pin changes from LOW to HIGH the callback will be called.\n* FALLING: When pin changes from HIGH to LOW, the callback will be called.\n\n\nSame pins from different ports cannot be used. For exaple PA3 and PB3 cannot be used as interrupt simultaneously.\n\n\nPredefined pin constants\n\n\nThe following constants are defined in the variant.h file for each variant:\n\n\n\n\n\n\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nLED_BUILTIN\n\n\nThe primary LED on board, if there is any\n\n\n\n\n\n\nSTM32_LED_BUILTIN_ACTIVE_LOW\n\n\nIf set, the onboard LED lights up when output is set to LOW\n\n\n\n\n\n\nMOSI\n\n\nMOSI pin of the first \nSPI\n\n\n\n\n\n\nMISO\n\n\nMISO pin of the first \nSPI\n\n\n\n\n\n\nSCK\n\n\nSCK  pin of the first \nSPI\n\n\n\n\n\n\nSDA\n\n\nSDA pin of the first \nI2C\n\n\n\n\n\n\nSCL\n\n\nSCL pin of the first \nI2C", 
            "title": "Arduino API"
        }, 
        {
            "location": "/arduino_api/#overview", 
            "text": "STM32GENERIC uses standard C and C++, so control sturctures (if, for), data types(int, long), syntax, etc... work as expected.  Non microcontroller-specific Arduino utility functions such as isLowerCase(), bitRead() etc... also work.  All non-standard functions are prefixed with  stm32XXXX()", 
            "title": "Overview"
        }, 
        {
            "location": "/arduino_api/#uint32_t-millis", 
            "text": "Returns the milliseconds since the microcontroller started. Overflows in 50 days.", 
            "title": "uint32_t millis();"
        }, 
        {
            "location": "/arduino_api/#uint32_t-micros", 
            "text": "Returns the microseconds since the microcontroller started. Overflows in 70 minutes.", 
            "title": "uint32_t micros();"
        }, 
        {
            "location": "/arduino_api/#delayuint32_t-millis", 
            "text": "Delays the execution by the given milliseconds.", 
            "title": "delay(uint32_t millis);"
        }, 
        {
            "location": "/arduino_api/#delaymicrosecondsuint32_t-micros", 
            "text": "Delays the execution by the given microseconds.   Example: Print the milliseconds on  Serial , every second:   void setup() {\n  Serial.begin(9600);\n}\nvoid loop() {\n  Serial.println(millis());\n  delay(1000);\n}   Uses STM32 SysTick, set to interrupt 1ms intervals.   Naming the pins in code:   STM32 chip pins have names:  PA0 ,  PA1 ...  On some boards (Nucleo, Maple), there are numbers / alternative names next to the pin:  1 ,  RX ,  A0 .  Predefined constants  for primary LED, SPI, Serial, I2C are defined in the variant file for the specific board.   Generally you should stick to naming the pin the same as they appear on the board to reduce confusion. If on the board you see ABC, use digitalWrite(ABC, HIGH);", 
            "title": "delayMicroseconds(uint32_t micros);"
        }, 
        {
            "location": "/arduino_api/#pinmodeuint8_t-pin-uint8_t-mode", 
            "text": "Sets the pin for digital reading / writing     Mode  Meaning      OUTPUT  0V - 3.3V    INPUT  The pin does not have a pull down or pull up resistor    INPUT_PULLUP  Weak pull up resistor to default to HIGH if the pin is not connected to anything    INPUT_PULLDOWN  Weak pull down resistor to default to LOW if the pin is not connected to anything     pinMode() is needed for digitalRead() and digitalWrite() functions.  The system automatically sets the pinMode when using a peripheral library like analogRead(), analogWrite(),  SPI  or  I2C , so you don't have to.", 
            "title": "pinMode(uint8_t pin, uint8_t mode);"
        }, 
        {
            "location": "/arduino_api/#digitalreaduint8_t-pin", 
            "text": "Read the voltage level on the specified pin. Returns LOW(0) if it is 0V, HIGH(1) if it is 3.3V  All pins can be used as digital input.  Not all pins are 5V tolerant. Please check the chip reference manual  Pinouts and pin description  section.", 
            "title": "digitalRead(uint8_t pin);"
        }, 
        {
            "location": "/arduino_api/#digitalwriteuint8_t-pin-uint8_t-value", 
            "text": "If value if LOW(0), sets the pin to 0V. If value is HIGH(1), 3.3V. All pins can be used as digital output.   Example: Blink the  LED  on the board:   void setup() {\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n  delay(1000);\n}", 
            "title": "digitalWrite(uint8_t pin, uint8_t value);"
        }, 
        {
            "location": "/arduino_api/#int-analogreaduint8_t-pin", 
            "text": "Read the voltage level on the pin, and map the 0..3.3V range to 0..1023 range by default.  Not all pins can be used as analog input!  Please check the  Boards page .", 
            "title": "int analogRead(uint8_t pin);"
        }, 
        {
            "location": "/arduino_api/#analogreadresolution", 
            "text": "TODO not yet implemented", 
            "title": "analogReadResolution()"
        }, 
        {
            "location": "/arduino_api/#analogwriteuint8_t-pin-int-value", 
            "text": "Set PWM to the specified pin.  All pins can be used as analog/PWM output.   Uses the TIM2 clock interrupt with software PWM implementation to allow PWM on all pins.", 
            "title": "analogWrite(uint8_t pin, int value)"
        }, 
        {
            "location": "/arduino_api/#analogwriteresolution", 
            "text": "TODO not yet implemented   Example: Dim the LED based on the voltage value on PA0   void loop() {\n    analogWrite(LED_BUILTIN, analogRead(PA0));\n    delay(10);\n}", 
            "title": "analogWriteResolution()"
        }, 
        {
            "location": "/arduino_api/#void-attachinterruptuint8_t-callback-int-mode", 
            "text": "Setup callback on the specified pin. Mode can be:   CHANGE: When pin changes from LOW to HIGH, or HIGH to LOW, the callback will be called.   RISING: When pin changes from LOW to HIGH the callback will be called.\n* FALLING: When pin changes from HIGH to LOW, the callback will be called.  Same pins from different ports cannot be used. For exaple PA3 and PB3 cannot be used as interrupt simultaneously.", 
            "title": "void attachInterrupt(uint8_t, callback, int mode);"
        }, 
        {
            "location": "/arduino_api/#predefined-pin-constants", 
            "text": "The following constants are defined in the variant.h file for each variant:     Constant  Meaning      LED_BUILTIN  The primary LED on board, if there is any    STM32_LED_BUILTIN_ACTIVE_LOW  If set, the onboard LED lights up when output is set to LOW    MOSI  MOSI pin of the first  SPI    MISO  MISO pin of the first  SPI    SCK  SCK  pin of the first  SPI    SDA  SDA pin of the first  I2C    SCL  SCL pin of the first  I2C", 
            "title": "Predefined pin constants"
        }, 
        {
            "location": "/spi/", 
            "text": "SPI\n\n\nTo use the hardware SPI, include it in your code:\n\n\n#include \nSPI.h\n\n\n\n\n\nThe first SPI object is explicitly created, and is connected to the SPI1 instance.\n\n\nPlease check your board documentation to see which pins is SPI connected to by default.\n\n\nTo use additional SPI, use the constructors to create your object, or the stm32SetInstance() method.\n\n\nSPIClass(SPI_TypeDef *instance)\n\n\nCreate a SPI object that is connected to the instance, on the default mosi/miso/sck. \nTo avoid confusion, it is better to use the constructor below with implicit pins.\n\n\nSPIClass(SPI_TypeDef *instance, uint8_t mosi, uint8_t miso, uint8_t sck)\n\n\nCreate a SPI object that is connected to the instance, on the specified mosi/miso/sck pins.\n\n\nPlease check the documentation of the chip to see which pins can be used.\n\n\n\n\nExample: set up SPI2\n\n\n\n\nSPIClass SPI_2(SPI2, mosi, iso, sck);\nvoid setup() {\n    SPI_2.begin();\n}\n\n\n\n\n\nbegin()\n\n\nEnables SPI on the pins\n\n\nend()\n\n\nDisables SPI on the pins\n\n\nbeginTransaction(SPISettings settings);\n\n\nInitializes SPI with the provided \nSPISettings mySetting(speedMaximum, dataOrder, dataMode)\n parameters.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nspeedMaximum\n\n\nThe maximum speed requested\n\n\n\n\n\n\ndataOrder\n\n\nMSBFIRST\n, \nLSBFIRST\n\n\n\n\n\n\ndataMode\n\n\nSPI_MODE0\n, \nSPI_MODE1\n, \nSPI_MODE2\n, or \nSPI_MODE3\n\n\n\n\n\n\n\n\nExample:\n\n\nSPI.beginTransaction(SPISettings(16000000, MSBFIRST, SPI_MODE0));\n\n\n\n\nendTransaction();\n\n\nuint8_t transfer(uint8_t data);\n\n\nSend a 8 bits on SPI, and return the received 8 bit data.\n\n\nuint16_t transfer16(uint16_t data);\n\n\nSend a 16 bits on SPI, and return the received 16 bit data.\n\n\ntransfer(uint8_t *buf, size_t count);\n\n\nSend the data in the buffer. The received data is stored in the same buffer.\n\n\ntransfer(tx, rxBuffer, size_t count[, callback]);\n\n\n\n\n\n\n\n\ntx\n\n\n\n\n\n\n\n\n\n\n\n\nuint8_t txData\n\n\nthe same byte is sent \ncount\n times\n\n\n\n\n\n\nuint8_t *txBuffer\n\n\nthe buffer is sent\n\n\n\n\n\n\nNULL\n\n\n0xFF is sent \ncount\n times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrxBuffer\n\n\n\n\n\n\n\n\n\n\n\n\nuint8_t *rxBuffer\n\n\nthe received data is stored in the rxBuffer\n\n\n\n\n\n\nNULL\n\n\nthe received data is ignored\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\n\n\n\n\n\n\n\n\n\n\nparameter not set\n\n\ntransfer is blocking\n\n\n\n\n\n\nNULL\n\n\ntransfer is \nnon-blocking\n, sends the data using DMA, and returns immediately.\n\n\n\n\n\n\nfunction pointer\n\n\ntransfer is \nnon-blocking\n, sends the data using DMA, and returns immediately.  At the end of the transfer, the callback function is called in interrupt.\n\n\n\n\n\n\n\n\nvoid flush(void);\n\n\nWaits for the last non-blocking transfer to complete.\n\n\nbool done(void);\n\n\nReturns true if the last non-blocking transfer is completed.\n\n\nstm32SetMOSI(uint8_t pin);\n\n\nSet the MOSI pin used by this SPI.\n\n\nThis method must be called before begin()!\n\n\nstm32SetMISO(uint8_t pin);\n\n\nSet the alternative MISO pin used by this SPI.\n\n\nThis method must be called before begin()!\n\n\nstm32SetSCK(uint8_t pin);\n\n\nSet the alternative SCK pin used by this SPI.\n\n\nThis method must be called before begin()!\n\n\nstm32SetInstance(SPI_TypeDef *instance);\n\n\nSet the alternative SPI instance (SPI1/SPI2/...) used by this object.\n\n\nThis method must be called before begin()!\n\n\n\n\nExample: If you want to use a library that has hardcoded \nSPI\n in it, but you want to use SPI2:\n\n\n\n\n#include \nSPI.h\n\n\nvoid setup() {\n    SPI.stm32SetInstance(SPI2);\n    SPI.stm32SetMOSI(mosi);\n    SPI.stm32SetMISO(miso);\n    SPI.stm32SetSCK(sck);\n    ...\n    library.begin();\n}", 
            "title": "SPI"
        }, 
        {
            "location": "/spi/#spi", 
            "text": "To use the hardware SPI, include it in your code:  #include  SPI.h   The first SPI object is explicitly created, and is connected to the SPI1 instance.  Please check your board documentation to see which pins is SPI connected to by default.  To use additional SPI, use the constructors to create your object, or the stm32SetInstance() method.", 
            "title": "SPI"
        }, 
        {
            "location": "/spi/#spiclassspi_typedef-instance", 
            "text": "Create a SPI object that is connected to the instance, on the default mosi/miso/sck. \nTo avoid confusion, it is better to use the constructor below with implicit pins.", 
            "title": "SPIClass(SPI_TypeDef *instance)"
        }, 
        {
            "location": "/spi/#spiclassspi_typedef-instance-uint8_t-mosi-uint8_t-miso-uint8_t-sck", 
            "text": "Create a SPI object that is connected to the instance, on the specified mosi/miso/sck pins.  Please check the documentation of the chip to see which pins can be used.   Example: set up SPI2   SPIClass SPI_2(SPI2, mosi, iso, sck);\nvoid setup() {\n    SPI_2.begin();\n}", 
            "title": "SPIClass(SPI_TypeDef *instance, uint8_t mosi, uint8_t miso, uint8_t sck)"
        }, 
        {
            "location": "/spi/#begin", 
            "text": "Enables SPI on the pins", 
            "title": "begin()"
        }, 
        {
            "location": "/spi/#end", 
            "text": "Disables SPI on the pins", 
            "title": "end()"
        }, 
        {
            "location": "/spi/#begintransactionspisettings-settings", 
            "text": "Initializes SPI with the provided  SPISettings mySetting(speedMaximum, dataOrder, dataMode)  parameters.     Parameter  Description      speedMaximum  The maximum speed requested    dataOrder  MSBFIRST ,  LSBFIRST    dataMode  SPI_MODE0 ,  SPI_MODE1 ,  SPI_MODE2 , or  SPI_MODE3     Example:  SPI.beginTransaction(SPISettings(16000000, MSBFIRST, SPI_MODE0));", 
            "title": "beginTransaction(SPISettings settings);"
        }, 
        {
            "location": "/spi/#endtransaction", 
            "text": "", 
            "title": "endTransaction();"
        }, 
        {
            "location": "/spi/#uint8_t-transferuint8_t-data", 
            "text": "Send a 8 bits on SPI, and return the received 8 bit data.", 
            "title": "uint8_t transfer(uint8_t data);"
        }, 
        {
            "location": "/spi/#uint16_t-transfer16uint16_t-data", 
            "text": "Send a 16 bits on SPI, and return the received 16 bit data.", 
            "title": "uint16_t transfer16(uint16_t data);"
        }, 
        {
            "location": "/spi/#transferuint8_t-buf-size_t-count", 
            "text": "Send the data in the buffer. The received data is stored in the same buffer.", 
            "title": "transfer(uint8_t *buf, size_t count);"
        }, 
        {
            "location": "/spi/#transfertx-rxbuffer-size_t-count-callback", 
            "text": "tx       uint8_t txData  the same byte is sent  count  times    uint8_t *txBuffer  the buffer is sent    NULL  0xFF is sent  count  times        rxBuffer       uint8_t *rxBuffer  the received data is stored in the rxBuffer    NULL  the received data is ignored        callback       parameter not set  transfer is blocking    NULL  transfer is  non-blocking , sends the data using DMA, and returns immediately.    function pointer  transfer is  non-blocking , sends the data using DMA, and returns immediately.  At the end of the transfer, the callback function is called in interrupt.", 
            "title": "transfer(tx, rxBuffer, size_t count[, callback]);"
        }, 
        {
            "location": "/spi/#void-flushvoid", 
            "text": "Waits for the last non-blocking transfer to complete.", 
            "title": "void flush(void);"
        }, 
        {
            "location": "/spi/#bool-donevoid", 
            "text": "Returns true if the last non-blocking transfer is completed.", 
            "title": "bool done(void);"
        }, 
        {
            "location": "/spi/#stm32setmosiuint8_t-pin", 
            "text": "Set the MOSI pin used by this SPI.  This method must be called before begin()!", 
            "title": "stm32SetMOSI(uint8_t pin);"
        }, 
        {
            "location": "/spi/#stm32setmisouint8_t-pin", 
            "text": "Set the alternative MISO pin used by this SPI.  This method must be called before begin()!", 
            "title": "stm32SetMISO(uint8_t pin);"
        }, 
        {
            "location": "/spi/#stm32setsckuint8_t-pin", 
            "text": "Set the alternative SCK pin used by this SPI.  This method must be called before begin()!", 
            "title": "stm32SetSCK(uint8_t pin);"
        }, 
        {
            "location": "/spi/#stm32setinstancespi_typedef-instance", 
            "text": "Set the alternative SPI instance (SPI1/SPI2/...) used by this object.  This method must be called before begin()!   Example: If you want to use a library that has hardcoded  SPI  in it, but you want to use SPI2:   #include  SPI.h \n\nvoid setup() {\n    SPI.stm32SetInstance(SPI2);\n    SPI.stm32SetMOSI(mosi);\n    SPI.stm32SetMISO(miso);\n    SPI.stm32SetSCK(sck);\n    ...\n    library.begin();\n}", 
            "title": "stm32SetInstance(SPI_TypeDef *instance);"
        }, 
        {
            "location": "/i2c/", 
            "text": "I2C\n\n\nTo use the hardware I2C, include it in your code:\n\n\n#include \nWire.h\n\n\n\n\n\nThe first I2C object is explicitly created, and is connected to the I2C1 instance.\n\n\nPlease check your board documentation to see which pins is I2C connected to by default.\n\n\nTo use additional I2C, use the constructors to create your object, or the stm32SetInstance() method.\n\n\nbegin()\n\n\nStart the I2C in master mode with default 100Khz speed.\n\n\nbegin(uint8_t address)\n\n\nStart the I2C in slave mode with default 100Khz speed. Slave mode currently does not work in F1 chips.\n\n\nbeginTransmission(uint8_t address)\n\n\nSet the address for the next transmission.\n\n\nwrite(uint8_t data)\n\n\nMaster mode: writes the data into a buffer to be send out in \nendTransmission\n.\n\n\nSlave mode: Send response to master. Currently can only be used inside the onRequest callback.\n\n\nendTransmission()\n\n\nSend the buffer to the slave.\n\n\nuint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)\n\n\nRequests data from the slave. Returns the number of bytes read into the receive buffer.\n\n\nThe data then can be retrieved using \nread()\n. \n\n\nint available()\n\n\nReturns data available in the receive buffer.\n\n\nint read()\n\n\nReturns the next byte in the receive buffer, or -1, if no more data available.\n\n\nSetClock(uint32_t frequency)\n\n\nSet the I2C clock frequency, and reinitializes the I2C peripheral.\n\n\nonReceive(void (*callback)(int))\n\n\nSets the callback function in slave mode. When data is received, this will be called. \n\n\nThe current implementation calls this for every byte received.\n\n\nonRequest(void (*callback)(void))\n\n\nSets the callback function in slave mode. When data is requested, this will be called.\n\n\nYou can respond to the master using the \nwrite()\n method.\n\n\nstm32SetSDA(uint8_t pin);\n\n\nSet the SDA pin used by this I2C.\n\n\nThis method must be called before begin()!\n\n\nstm32SetSCL(uint8_t pin);\n\n\nSet the alternative SCL pin used by this I2C.\n\n\nThis method must be called before begin()!\n\n\nstm32SetInstance(I2C_TypeDef *instance);\n\n\nSet the alternative I2C instance (I2C1/I2C2/...) used by this object.\n\n\nThis method must be called before begin()!\n\n\n\n\nExample: If you want to use a library that has hardcoded \nI2C\n in it, but you want to use I2C2:\n\n\n\n\n#include \nWire.h\n\n\nvoid setup() {\n    Wire.stm32SetInstance(I2C2);\n    Wire.stm32SetSDA(sda);\n    Wire.stm32SetSCL(scl);\n    ...\n    library.begin();\n}", 
            "title": "I2C"
        }, 
        {
            "location": "/i2c/#i2c", 
            "text": "To use the hardware I2C, include it in your code:  #include  Wire.h   The first I2C object is explicitly created, and is connected to the I2C1 instance.  Please check your board documentation to see which pins is I2C connected to by default.  To use additional I2C, use the constructors to create your object, or the stm32SetInstance() method.", 
            "title": "I2C"
        }, 
        {
            "location": "/i2c/#begin", 
            "text": "Start the I2C in master mode with default 100Khz speed.", 
            "title": "begin()"
        }, 
        {
            "location": "/i2c/#beginuint8_t-address", 
            "text": "Start the I2C in slave mode with default 100Khz speed. Slave mode currently does not work in F1 chips.", 
            "title": "begin(uint8_t address)"
        }, 
        {
            "location": "/i2c/#begintransmissionuint8_t-address", 
            "text": "Set the address for the next transmission.", 
            "title": "beginTransmission(uint8_t address)"
        }, 
        {
            "location": "/i2c/#writeuint8_t-data", 
            "text": "Master mode: writes the data into a buffer to be send out in  endTransmission .  Slave mode: Send response to master. Currently can only be used inside the onRequest callback.", 
            "title": "write(uint8_t data)"
        }, 
        {
            "location": "/i2c/#endtransmission", 
            "text": "Send the buffer to the slave.", 
            "title": "endTransmission()"
        }, 
        {
            "location": "/i2c/#uint8_t-requestfromuint8_t-address-uint8_t-quantity-uint8_t-sendstop", 
            "text": "Requests data from the slave. Returns the number of bytes read into the receive buffer.  The data then can be retrieved using  read() .", 
            "title": "uint8_t requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)"
        }, 
        {
            "location": "/i2c/#int-available", 
            "text": "Returns data available in the receive buffer.", 
            "title": "int available()"
        }, 
        {
            "location": "/i2c/#int-read", 
            "text": "Returns the next byte in the receive buffer, or -1, if no more data available.", 
            "title": "int read()"
        }, 
        {
            "location": "/i2c/#setclockuint32_t-frequency", 
            "text": "Set the I2C clock frequency, and reinitializes the I2C peripheral.", 
            "title": "SetClock(uint32_t frequency)"
        }, 
        {
            "location": "/i2c/#onreceivevoid-callbackint", 
            "text": "Sets the callback function in slave mode. When data is received, this will be called.   The current implementation calls this for every byte received.", 
            "title": "onReceive(void (*callback)(int))"
        }, 
        {
            "location": "/i2c/#onrequestvoid-callbackvoid", 
            "text": "Sets the callback function in slave mode. When data is requested, this will be called.  You can respond to the master using the  write()  method.", 
            "title": "onRequest(void (*callback)(void))"
        }, 
        {
            "location": "/i2c/#stm32setsdauint8_t-pin", 
            "text": "Set the SDA pin used by this I2C.  This method must be called before begin()!", 
            "title": "stm32SetSDA(uint8_t pin);"
        }, 
        {
            "location": "/i2c/#stm32setscluint8_t-pin", 
            "text": "Set the alternative SCL pin used by this I2C.  This method must be called before begin()!", 
            "title": "stm32SetSCL(uint8_t pin);"
        }, 
        {
            "location": "/i2c/#stm32setinstancei2c_typedef-instance", 
            "text": "Set the alternative I2C instance (I2C1/I2C2/...) used by this object.  This method must be called before begin()!   Example: If you want to use a library that has hardcoded  I2C  in it, but you want to use I2C2:   #include  Wire.h \n\nvoid setup() {\n    Wire.stm32SetInstance(I2C2);\n    Wire.stm32SetSDA(sda);\n    Wire.stm32SetSCL(scl);\n    ...\n    library.begin();\n}", 
            "title": "stm32SetInstance(I2C_TypeDef *instance);"
        }, 
        {
            "location": "/i2s/", 
            "text": "I2S\n\n\nNot to be confused with \nI2C\n, is a protocol for connecting to audio devices.\nThe samples are sent continuously in the background using DMA transfer. \n\n\nThis library is in beta, and the API / implementation is subject to change!\n\n\nTo use this library, include it in your code:\n\n\n#include \nI2S.h\n\n\nI2SClass i2s(...);\n\n\n\n\n\nI2SClass(SPI_TypeDef *instance);\n\n\nConstruct I2S that will be connected to the specified I2S instance on chip.\n\n\nThe board default pins will be used for sd/ws/ck. mck will not be used.\n\n\nI2SClass(SPI_TypeDef *instance, uint8_t sd, uint8_t ws, uint8_t ck);\n\n\nConstruct I2S that will be connected to the specified I2S instance on chip.\n\n\nThe specified pins will be used for sd/ws/ck. mck will not be used.\n\n\nI2SClass(SPI_TypeDef *instance, uint8_t sd, uint8_t ws, uint8_t ck, uint8_t mck);\n\n\nConstruct I2S that will be connected to the specified I2S instance on chip.\n\n\nThe specified pins will be used for sd/ws/ck/mck.\n\n\nuint8_t I2SClass::begin(i2s_mode_t mode, uint32_t sampleRate, uint8_t bitsPerSample);\n\n\nConfigure the pins, and the parameters for the connection.\n\n\n\n\nmode: one of I2S_PHILIPS_MODE,I2S_RIGHT_JUSTIFIED_MODE, I2S_LEFT_JUSTIFIED_MODE\n\n\nsampleRate: between 8000 and 96000\n\n\nbitsPerSample: 16. \n (Note: 24 or 32 bit per sample currently not working!) \n\n\n\n\nwrite(int16_t data);\n\n\nSend 16 bit data. Blocks if there is no space left in the internal buffer.\n\n\nwrite(int16_t *data, uint16_t size);\n\n\nSend 16 bit data. Blocks if there is no space left in the internal buffer.\n\n\nsetBuffer(uint16_t *buffer, int bufferSize);\n\n\nSet the DMA transfer buffer size. The default buffer is 2048 * 16 bits.\n\n\nint getBufferSize();\n\n\nReturns size of the transfer buffer.\n\n\nstm32SetSD(uint8_t pin);\n\n\nSet the alternative SD pin used by this I2S.\n\n\nThis method must be called before begin()!\n\n\nstm32SetWD(uint8_t pin);\n\n\nSet the alternative WD pin used by this I2S.\n\n\nThis method must be called before begin()!\n\n\nstm32SetCK(uint8_t pin);\n\n\nSet the alternative CK pin used by this I2S.\n\n\nThis method must be called before begin()!\n\n\nstm32SetMCK(uint8_t pin);\n\n\nSet the alternative MCK pin used by this I2S.\n\n\nThis method must be called before begin()!", 
            "title": "I2S"
        }, 
        {
            "location": "/i2s/#i2s", 
            "text": "Not to be confused with  I2C , is a protocol for connecting to audio devices.\nThe samples are sent continuously in the background using DMA transfer.", 
            "title": "I2S"
        }, 
        {
            "location": "/i2s/#this-library-is-in-beta-and-the-api-implementation-is-subject-to-change", 
            "text": "To use this library, include it in your code:  #include  I2S.h \n\nI2SClass i2s(...);", 
            "title": "This library is in beta, and the API / implementation is subject to change!"
        }, 
        {
            "location": "/i2s/#i2sclassspi_typedef-instance", 
            "text": "Construct I2S that will be connected to the specified I2S instance on chip.  The board default pins will be used for sd/ws/ck. mck will not be used.", 
            "title": "I2SClass(SPI_TypeDef *instance);"
        }, 
        {
            "location": "/i2s/#i2sclassspi_typedef-instance-uint8_t-sd-uint8_t-ws-uint8_t-ck", 
            "text": "Construct I2S that will be connected to the specified I2S instance on chip.  The specified pins will be used for sd/ws/ck. mck will not be used.", 
            "title": "I2SClass(SPI_TypeDef *instance, uint8_t sd, uint8_t ws, uint8_t ck);"
        }, 
        {
            "location": "/i2s/#i2sclassspi_typedef-instance-uint8_t-sd-uint8_t-ws-uint8_t-ck-uint8_t-mck", 
            "text": "Construct I2S that will be connected to the specified I2S instance on chip.  The specified pins will be used for sd/ws/ck/mck.", 
            "title": "I2SClass(SPI_TypeDef *instance, uint8_t sd, uint8_t ws, uint8_t ck, uint8_t mck);"
        }, 
        {
            "location": "/i2s/#uint8_t-i2sclassbegini2s_mode_t-mode-uint32_t-samplerate-uint8_t-bitspersample", 
            "text": "Configure the pins, and the parameters for the connection.   mode: one of I2S_PHILIPS_MODE,I2S_RIGHT_JUSTIFIED_MODE, I2S_LEFT_JUSTIFIED_MODE  sampleRate: between 8000 and 96000  bitsPerSample: 16.   (Note: 24 or 32 bit per sample currently not working!)", 
            "title": "uint8_t I2SClass::begin(i2s_mode_t mode, uint32_t sampleRate, uint8_t bitsPerSample);"
        }, 
        {
            "location": "/i2s/#writeint16_t-data", 
            "text": "Send 16 bit data. Blocks if there is no space left in the internal buffer.", 
            "title": "write(int16_t data);"
        }, 
        {
            "location": "/i2s/#writeint16_t-data-uint16_t-size", 
            "text": "Send 16 bit data. Blocks if there is no space left in the internal buffer.", 
            "title": "write(int16_t *data, uint16_t size);"
        }, 
        {
            "location": "/i2s/#setbufferuint16_t-buffer-int-buffersize", 
            "text": "Set the DMA transfer buffer size. The default buffer is 2048 * 16 bits.", 
            "title": "setBuffer(uint16_t *buffer, int bufferSize);"
        }, 
        {
            "location": "/i2s/#int-getbuffersize", 
            "text": "Returns size of the transfer buffer.", 
            "title": "int getBufferSize();"
        }, 
        {
            "location": "/i2s/#stm32setsduint8_t-pin", 
            "text": "Set the alternative SD pin used by this I2S.  This method must be called before begin()!", 
            "title": "stm32SetSD(uint8_t pin);"
        }, 
        {
            "location": "/i2s/#stm32setwduint8_t-pin", 
            "text": "Set the alternative WD pin used by this I2S.  This method must be called before begin()!", 
            "title": "stm32SetWD(uint8_t pin);"
        }, 
        {
            "location": "/i2s/#stm32setckuint8_t-pin", 
            "text": "Set the alternative CK pin used by this I2S.  This method must be called before begin()!", 
            "title": "stm32SetCK(uint8_t pin);"
        }, 
        {
            "location": "/i2s/#stm32setmckuint8_t-pin", 
            "text": "Set the alternative MCK pin used by this I2S.  This method must be called before begin()!", 
            "title": "stm32SetMCK(uint8_t pin);"
        }, 
        {
            "location": "/sdio/", 
            "text": "SDIO / SDMMC\n\n\nTo use the hardware SDIO, include it in your code:\n\n\n#include \nSDIO.h\n\n\nSDIOClass sdio;\n\n\n\n\nbegin();\n\n\nConnects to the SDIO card, using 4-bit mode.\n\n\nReturns true on success, false on failure.\nOn failure, use \ngetError()\n.\n\n\nuint8_t end();\n\n\nDisconnects from the SDIO card.\n\n\nuint32_t getBlockSize();\n\n\nReturns the block size.\n\n\nuint8_t readBlocks(uint32_t block, uint8_t* dst, size_t blocks);\n\n\nRead the given number of blocks into dst buffer in blocking mode.\n\n\nuint8_t writeBlocks(uint32_t block, const uint8_t* src, size_t blocks);\n\n\nWrites the given number of blocks from the buffer in blocking mode.\n\n\nuint8_t eraseBlocks(uint32_t startBlock, uint32_t endBlock);\n\n\nErases the blocks from start block to end block.\n\n\nHAL_SD_ErrorTypedef getError();\n\n\nReturns the last error type.\n\n\nuint64_t getCapacity();\n\n\nReturns the SD Card capacity.\n\n\nuint8_t getType();\n\n\nReturns the type of the SD Card \n\n\nuint16_t getRCA();\n\n\nReturns the RCA register.\n\n\nHAL_SD_CIDTypedef getCID();\n\n\nReturns the CID register.\n\n\nHAL_SD_CSDTypedef getCSD();\n\n\nReturns the CSD register.", 
            "title": "SDIO"
        }, 
        {
            "location": "/sdio/#sdio-sdmmc", 
            "text": "To use the hardware SDIO, include it in your code:  #include  SDIO.h \n\nSDIOClass sdio;", 
            "title": "SDIO / SDMMC"
        }, 
        {
            "location": "/sdio/#begin", 
            "text": "Connects to the SDIO card, using 4-bit mode.  Returns true on success, false on failure.\nOn failure, use  getError() .", 
            "title": "begin();"
        }, 
        {
            "location": "/sdio/#uint8_t-end", 
            "text": "Disconnects from the SDIO card.", 
            "title": "uint8_t end();"
        }, 
        {
            "location": "/sdio/#uint32_t-getblocksize", 
            "text": "Returns the block size.", 
            "title": "uint32_t getBlockSize();"
        }, 
        {
            "location": "/sdio/#uint8_t-readblocksuint32_t-block-uint8_t-dst-size_t-blocks", 
            "text": "Read the given number of blocks into dst buffer in blocking mode.", 
            "title": "uint8_t readBlocks(uint32_t block, uint8_t* dst, size_t blocks);"
        }, 
        {
            "location": "/sdio/#uint8_t-writeblocksuint32_t-block-const-uint8_t-src-size_t-blocks", 
            "text": "Writes the given number of blocks from the buffer in blocking mode.", 
            "title": "uint8_t writeBlocks(uint32_t block, const uint8_t* src, size_t blocks);"
        }, 
        {
            "location": "/sdio/#uint8_t-eraseblocksuint32_t-startblock-uint32_t-endblock", 
            "text": "Erases the blocks from start block to end block.", 
            "title": "uint8_t eraseBlocks(uint32_t startBlock, uint32_t endBlock);"
        }, 
        {
            "location": "/sdio/#hal_sd_errortypedef-geterror", 
            "text": "Returns the last error type.", 
            "title": "HAL_SD_ErrorTypedef getError();"
        }, 
        {
            "location": "/sdio/#uint64_t-getcapacity", 
            "text": "Returns the SD Card capacity.", 
            "title": "uint64_t getCapacity();"
        }, 
        {
            "location": "/sdio/#uint8_t-gettype", 
            "text": "Returns the type of the SD Card", 
            "title": "uint8_t getType();"
        }, 
        {
            "location": "/sdio/#uint16_t-getrca", 
            "text": "Returns the RCA register.", 
            "title": "uint16_t getRCA();"
        }, 
        {
            "location": "/sdio/#hal_sd_cidtypedef-getcid", 
            "text": "Returns the CID register.", 
            "title": "HAL_SD_CIDTypedef getCID();"
        }, 
        {
            "location": "/sdio/#hal_sd_csdtypedef-getcsd", 
            "text": "Returns the CSD register.", 
            "title": "HAL_SD_CSDTypedef getCSD();"
        }, 
        {
            "location": "/uart/", 
            "text": "Serial UART\n\n\nThere are two implementations of Serial communication: UART and USB. \n\n\nThis page describes the UART based.\n\n\nPlease check the \nMenu option\n to see which one is selected.\n\n\nSerialUART1\nis bound to UART1, \nSerialUART2\n to UART2 etc...\n\n\nPlease refer to the \nofficial documentation\n for\nthe description of Serial functions.\n\n\nSerialUARTx.stm32SetRX(uint8_t pin)\n\n\nSet the RX signal to the specified pin. Please check the chip documentation for which pin can be used for RX.\nThis must be called before begin()!\n\n\nSerialUARTx.stm32SetTx(uint8_t pin)\n\n\nSet the TX signal to the specified pin. Please check the chip documentation for which pin can be used for TX.\nThis must be called before begin()!\n\n\n\n\nExample: The following code will echo the received bytes on UART2\n\n\n\n\nvoid setup() {\n    SerialUART2.stm32SetRX(Pcd);\n    SerialUART2.stm32SetTX(Pab);\n    SerualUART2.begin(115200);\n}\nvoid loop() {\n    int data = SerialUART2.read();\n    if (data != -1) {\n        SerialUART2.write(data);\n    }\n}", 
            "title": "UART Serial"
        }, 
        {
            "location": "/uart/#serial-uart", 
            "text": "There are two implementations of Serial communication: UART and USB.   This page describes the UART based.  Please check the  Menu option  to see which one is selected.  SerialUART1 is bound to UART1,  SerialUART2  to UART2 etc...  Please refer to the  official documentation  for\nthe description of Serial functions.", 
            "title": "Serial UART"
        }, 
        {
            "location": "/uart/#serialuartxstm32setrxuint8_t-pin", 
            "text": "Set the RX signal to the specified pin. Please check the chip documentation for which pin can be used for RX.\nThis must be called before begin()!", 
            "title": "SerialUARTx.stm32SetRX(uint8_t pin)"
        }, 
        {
            "location": "/uart/#serialuartxstm32settxuint8_t-pin", 
            "text": "Set the TX signal to the specified pin. Please check the chip documentation for which pin can be used for TX.\nThis must be called before begin()!   Example: The following code will echo the received bytes on UART2   void setup() {\n    SerialUART2.stm32SetRX(Pcd);\n    SerialUART2.stm32SetTX(Pab);\n    SerualUART2.begin(115200);\n}\nvoid loop() {\n    int data = SerialUART2.read();\n    if (data != -1) {\n        SerialUART2.write(data);\n    }\n}", 
            "title": "SerialUARTx.stm32SetTx(uint8_t pin)"
        }, 
        {
            "location": "/usb_cdc/", 
            "text": "USB: Serial\n\n\nThere are two implementations of Serial communication: UART and USB. \n\n\nThis page describes the USB based.\n\n\nPlease check the \nMenu option\n to see which one is selected as \nSerial\n.\n\n\nIf the \nUSB menu\n is set to include Serial, SerialUSB is set as a virtual COM port, and can be used just like a regular UART based.\n\n\nTODO explain windows 7 driver\n\n\nPlease refer to the \nofficial documentation\n for\nthe description of Serial functions.", 
            "title": "USB Serial"
        }, 
        {
            "location": "/usb_cdc/#usb-serial", 
            "text": "There are two implementations of Serial communication: UART and USB.   This page describes the USB based.  Please check the  Menu option  to see which one is selected as  Serial .  If the  USB menu  is set to include Serial, SerialUSB is set as a virtual COM port, and can be used just like a regular UART based.  TODO explain windows 7 driver  Please refer to the  official documentation  for\nthe description of Serial functions.", 
            "title": "USB: Serial"
        }, 
        {
            "location": "/usb_msc/", 
            "text": "USB: Mass Storage\n\n\nThis library is in beta\n\n\n\n\nSelect Mass Storage from the arduino tools/USB menu\n\n\nOverride the \nBlockDevice.h\n interface to provide implementation for reading / writing blocks\n\n\nInclude \nMassStorage.h\n, and implement the \nBlockDevice *getMassStorage()\n function\n\n\n\n\nThere is RAM implementation of BlockDevice, called RamBlockDevice. Example usage:\n\n\n#include \nArduino.h\n\n\n#include \nRamBlockDevice.h\n\n\nRamBlockDevice ramBlockDevice(100 /* x 512 blocks*/, true);\n\nBlockDevice *getMassStorage() {\n    return \nramBlockDevice;\n}\n\nvoid blinkOnRead(uint32_t block, size_t count) {\n    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n}\n\nvoid blinkOnWrite(uint32_t block, size_t count) {\n    digitalWrite(LED1_BUILTIN, !digitalRead(LED1_BUILTIN));\n}\n\nvoid setup() {\n    pinMode(LED_BUILTIN, OUTPUT);\n    pinMode(LED1_BUILTIN, OUTPUT);\n\n    ramBlockDevice.setReadListener(blinkOnRead);\n    ramBlockDevice.setWriteListener(blinkOnWrite);\n}\n\nvoid loop() {\n\n}", 
            "title": "USB Mass Storage"
        }, 
        {
            "location": "/usb_msc/#usb-mass-storage", 
            "text": "", 
            "title": "USB: Mass Storage"
        }, 
        {
            "location": "/usb_msc/#this-library-is-in-beta", 
            "text": "Select Mass Storage from the arduino tools/USB menu  Override the  BlockDevice.h  interface to provide implementation for reading / writing blocks  Include  MassStorage.h , and implement the  BlockDevice *getMassStorage()  function   There is RAM implementation of BlockDevice, called RamBlockDevice. Example usage:  #include  Arduino.h \n\n#include  RamBlockDevice.h \n\nRamBlockDevice ramBlockDevice(100 /* x 512 blocks*/, true);\n\nBlockDevice *getMassStorage() {\n    return  ramBlockDevice;\n}\n\nvoid blinkOnRead(uint32_t block, size_t count) {\n    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n}\n\nvoid blinkOnWrite(uint32_t block, size_t count) {\n    digitalWrite(LED1_BUILTIN, !digitalRead(LED1_BUILTIN));\n}\n\nvoid setup() {\n    pinMode(LED_BUILTIN, OUTPUT);\n    pinMode(LED1_BUILTIN, OUTPUT);\n\n    ramBlockDevice.setReadListener(blinkOnRead);\n    ramBlockDevice.setWriteListener(blinkOnWrite);\n}\n\nvoid loop() {\n\n}", 
            "title": "This library is in beta"
        }, 
        {
            "location": "/stm32_hal/", 
            "text": "", 
            "title": "STM32 HAL"
        }, 
        {
            "location": "/libraries/", 
            "text": "TODO automatically compile all libraries, and show results here", 
            "title": "Libraries"
        }, 
        {
            "location": "/boards/", 
            "text": "Boards:\n\n\nTODO generate this page from boards.txt, cube db files, and variant.h for default pins.", 
            "title": "Boards list"
        }, 
        {
            "location": "/boards/#boards", 
            "text": "TODO generate this page from boards.txt, cube db files, and variant.h for default pins.", 
            "title": "Boards:"
        }, 
        {
            "location": "/add_board/", 
            "text": "Add your board:\n\n\n1. Create a copy of the STM32/variants/xxx folder with a name of your choice.\n\n\nUse one that is the most similar to your board\n\n\n2. Edit the ldscript.ld file\n\n\n\n\nChange the _estack to point to the end of RAM\n\n\nFLASH LENGTH to be the size of RAM of the microcontroller\n\n\nRAM LENGTH to be the size of RAM of the microcontroller\n\n\n\n\nTODO CCRAM, SDRAM.\n\n\n3. Edit the variant.h file\n\n\n\n\nChange LED_BUILTIN, MOSI, MISO... macros to point to the primary LED, primary SPI, primary I2C pins.\n\n\nAdd board specific macros if the board has extra leds, buttons, SPI CS select lines etc...\n\n\nIf the board has pin name - pin number assigments (for example arduino headers), Copy the VARIANT_PIN_LIST_DEFAULT from \nsystem/STM32XX/stm32_chip/stm32_STM32XXXXXX.h\n file, rename to VARIANT_PIN_LIST, and rearrange accordingly.\n\n\n\n\n4. Edit the variant.c file\n\n\n\n\nRun STM32CubeMX, select the chip for your board\n\n\nIf the board has external crystal, set RCC HSE to crystal. In clock configuration, set PLL Source to HSE, set HSE to the frequency of the board crystal.\n\n\nSet some peripherals (SPI, I2C, SDIO, USB, ...), so that the clock configuration will generate extra code needed for those peripherals, and bounds check the frequencies.\n\n\nGo to clock configuration, set everything to maximum :), let CubeMX figure out the rest.\n\n\nClick generate. Set toolchain/IDE to SW4STM32. Clik OK\n\n\nFrom the generated src/main.c, copy \nvoid SystemClock_Config(void) {\n into your \nvariant/.../variant.c\n\n\n\n\n5. Edit the boards.txt file\n\n\nCopy one that is the most similar to your board\n\n\n\n\nRename the board\n\n\nChange \nbuild.mcu=\n to your cortex-mX version\n\n\nChange \nbuild.series=\n to STM32XX, where XX is the chip series\n\n\nChange \nbuild.extra_flags=-DSTM32XXXXXX\n to be the exact chip version\n\n\nChange \nupload.maximum_size=\n and \nupload.maximum_data_size=\n to the RAM/FLASH size of the chip\n\n\nIf the external crystal is not the board default in \nsystem/STM32XX/HAL_SRC/system_stm32XXxx.c\n, add \n-DHSE_VALUE=8000000\n to \nxxx.build.extra_flags\n\n\nTODO explain upload / usb / serial menu options\n\n\n\n\n6. Restart\n\n\nRestart Arduino IDE\n\n\n7. Run the blink example on your new board\n\n\nRun examples / basic / blink", 
            "title": "Adding a board"
        }, 
        {
            "location": "/add_board/#add-your-board", 
            "text": "", 
            "title": "Add your board:"
        }, 
        {
            "location": "/add_board/#1-create-a-copy-of-the-stm32variantsxxx-folder-with-a-name-of-your-choice", 
            "text": "Use one that is the most similar to your board", 
            "title": "1. Create a copy of the STM32/variants/xxx folder with a name of your choice."
        }, 
        {
            "location": "/add_board/#2-edit-the-ldscriptld-file", 
            "text": "Change the _estack to point to the end of RAM  FLASH LENGTH to be the size of RAM of the microcontroller  RAM LENGTH to be the size of RAM of the microcontroller   TODO CCRAM, SDRAM.", 
            "title": "2. Edit the ldscript.ld file"
        }, 
        {
            "location": "/add_board/#3-edit-the-varianth-file", 
            "text": "Change LED_BUILTIN, MOSI, MISO... macros to point to the primary LED, primary SPI, primary I2C pins.  Add board specific macros if the board has extra leds, buttons, SPI CS select lines etc...  If the board has pin name - pin number assigments (for example arduino headers), Copy the VARIANT_PIN_LIST_DEFAULT from  system/STM32XX/stm32_chip/stm32_STM32XXXXXX.h  file, rename to VARIANT_PIN_LIST, and rearrange accordingly.", 
            "title": "3. Edit the variant.h file"
        }, 
        {
            "location": "/add_board/#4-edit-the-variantc-file", 
            "text": "Run STM32CubeMX, select the chip for your board  If the board has external crystal, set RCC HSE to crystal. In clock configuration, set PLL Source to HSE, set HSE to the frequency of the board crystal.  Set some peripherals (SPI, I2C, SDIO, USB, ...), so that the clock configuration will generate extra code needed for those peripherals, and bounds check the frequencies.  Go to clock configuration, set everything to maximum :), let CubeMX figure out the rest.  Click generate. Set toolchain/IDE to SW4STM32. Clik OK  From the generated src/main.c, copy  void SystemClock_Config(void) {  into your  variant/.../variant.c", 
            "title": "4. Edit the variant.c file"
        }, 
        {
            "location": "/add_board/#5-edit-the-boardstxt-file", 
            "text": "Copy one that is the most similar to your board   Rename the board  Change  build.mcu=  to your cortex-mX version  Change  build.series=  to STM32XX, where XX is the chip series  Change  build.extra_flags=-DSTM32XXXXXX  to be the exact chip version  Change  upload.maximum_size=  and  upload.maximum_data_size=  to the RAM/FLASH size of the chip  If the external crystal is not the board default in  system/STM32XX/HAL_SRC/system_stm32XXxx.c , add  -DHSE_VALUE=8000000  to  xxx.build.extra_flags  TODO explain upload / usb / serial menu options", 
            "title": "5. Edit the boards.txt file"
        }, 
        {
            "location": "/add_board/#6-restart", 
            "text": "Restart Arduino IDE", 
            "title": "6. Restart"
        }, 
        {
            "location": "/add_board/#7-run-the-blink-example-on-your-new-board", 
            "text": "Run examples / basic / blink", 
            "title": "7. Run the blink example on your new board"
        }, 
        {
            "location": "/test/", 
            "text": "Self tesing boards\n\n\nTo automatically check if the board works, there are tests in the library.\nThese work by connecting pins to \n\n\nGeneric STM32 Arduino API test\n\n\nThis test should work on almost all STM32 boards. \n\n\n\n\nFrom the arduino menu, select File/Examples/Examples for XXX/SelfTest\n\n\nConnect PA0 to PA1 to test digital/analog/read/write/interrupt\n\n\nConnect SPI MOSI to SPI MISO to test SPI\n\n\nSelect a free UART (not used for Serial) on the board, connect the RX to TX, set the SerialUartToTest macro in the sketch\n\n\nRun the sketch\n\n\n\n\nThe result should be short blink on the board LED.\nIf there was a failure, it is shown as a long LED \n\n\nThe results are also", 
            "title": "Testing a board"
        }, 
        {
            "location": "/test/#self-tesing-boards", 
            "text": "To automatically check if the board works, there are tests in the library.\nThese work by connecting pins to", 
            "title": "Self tesing boards"
        }, 
        {
            "location": "/test/#generic-stm32-arduino-api-test", 
            "text": "This test should work on almost all STM32 boards.    From the arduino menu, select File/Examples/Examples for XXX/SelfTest  Connect PA0 to PA1 to test digital/analog/read/write/interrupt  Connect SPI MOSI to SPI MISO to test SPI  Select a free UART (not used for Serial) on the board, connect the RX to TX, set the SerialUartToTest macro in the sketch  Run the sketch   The result should be short blink on the board LED.\nIf there was a failure, it is shown as a long LED   The results are also", 
            "title": "Generic STM32 Arduino API test"
        }, 
        {
            "location": "/about/", 
            "text": "Goals\n\n\n\n\nGeneric implementation using \nSTM32 HAL API\n to compile onto every STM32 board.\n\n\nFor the most used boards, optimize code paths using direct register access.\n\n\nMake adding boards easy\n\n\nMake as compatible with default libraries as  possible\n\n\n\n\nProject structure\n\n\n\n\n\n\n\n\nDirector\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsystem/CMSIS\n\n\nCMSIS header files from ARM for cortex-M0/M3/M4/M7 microcontrollers\n\n\n\n\n\n\nsystem/STM32XX/CMSIS_Inc\n\n\nCMSIS header files specific STM32 chips, contains memory layout and register access for every chip\n\n\n\n\n\n\nsystem/STM32XX/CMSIS_Src\n\n\nCMSIS startup assembly files specific STM32 chips, contains ISR vector for interrupt handlers and reset handler default implementation\n\n\n\n\n\n\nsystem/STM32XX/HAL_Inc\n\n\nSTM32 Hardware Abstraction Layer headers for every chip series\n\n\n\n\n\n\nsystem/STM32XX/HAL_Src\n\n\nSTM32 Hardware Abstraction Layer implementation for every chip series\n\n\n\n\n\n\nsystem/STM32XX/stm32_chip\n\n\nFor every chip, default and alternate pins, clock frequencies, cannels for peripherals: SPI, I2C, ADC... autogenerated from CubeMX db/*.xml files with tools/script/generate_build_define.py.\n\n\n\n\n\n\ncores/arduino/\n\n\nArduino API definitions and Arduino-utility functions.\n\n\n\n\n\n\ncores/arduino/stm32_HAL\n\n\nSelect (compile) the specific files from \nsystem/STM32XX/HAL_Src\n, based on boards.txt \n*.build.series\n value\n\n\n\n\n\n\ncores/arduino/usb\n\n\nSTM32 USB Middleware\n\n\n\n\n\n\ncores/arduino/stm32\n\n\nSTM32 implementation of the Arduino API. First implementation is a light wrapper around HAL\n\n\n\n\n\n\nlibraries/[SPI|Wire|...]\n\n\nSTM32 implementation of the Arduino libraries API. First implementation is a light wrapper around HAL\n\n\n\n\n\n\nvariants/.../*\n\n\nVariant specific files: \nldscript.ld\n for memory layout, \nsystemclock_config.c\n for clock setup, generated by STM32CubeMX, \nvariant.*\n for variant pin layout and pin definitions (pin layout can be copy/pasted from \nsystem/STM32XX/stm32_chip/*\n).\n\n\n\n\n\n\n\n\nGeneral development direction\n\n\n\n\nSelf-test code to run on a board to check if the API works for that variant.\n\n\nAutomatic unit test compilation. This ensures that a code change does not break other boards.\n\n\nAutomatic library compilation, to be as arduino-compatible as possible.\n\n\nBenchmarks to pinpoint bottlenecks.\n\n\nHacker-friendly: Enable to use HAL/CMSIS; enable overriding of every IRQ handler.\n\n\nAdd DFU/MSC/HID/MIDI to USB. Rewrite USB to PluggableUSB to be more arduino-compatible.\n\n\nCreate SDIO library\n\n\nCreate I2S library\n\n\nCreate CAN library", 
            "title": "About"
        }, 
        {
            "location": "/about/#goals", 
            "text": "Generic implementation using  STM32 HAL API  to compile onto every STM32 board.  For the most used boards, optimize code paths using direct register access.  Make adding boards easy  Make as compatible with default libraries as  possible", 
            "title": "Goals"
        }, 
        {
            "location": "/about/#project-structure", 
            "text": "Director  Description      system/CMSIS  CMSIS header files from ARM for cortex-M0/M3/M4/M7 microcontrollers    system/STM32XX/CMSIS_Inc  CMSIS header files specific STM32 chips, contains memory layout and register access for every chip    system/STM32XX/CMSIS_Src  CMSIS startup assembly files specific STM32 chips, contains ISR vector for interrupt handlers and reset handler default implementation    system/STM32XX/HAL_Inc  STM32 Hardware Abstraction Layer headers for every chip series    system/STM32XX/HAL_Src  STM32 Hardware Abstraction Layer implementation for every chip series    system/STM32XX/stm32_chip  For every chip, default and alternate pins, clock frequencies, cannels for peripherals: SPI, I2C, ADC... autogenerated from CubeMX db/*.xml files with tools/script/generate_build_define.py.    cores/arduino/  Arduino API definitions and Arduino-utility functions.    cores/arduino/stm32_HAL  Select (compile) the specific files from  system/STM32XX/HAL_Src , based on boards.txt  *.build.series  value    cores/arduino/usb  STM32 USB Middleware    cores/arduino/stm32  STM32 implementation of the Arduino API. First implementation is a light wrapper around HAL    libraries/[SPI|Wire|...]  STM32 implementation of the Arduino libraries API. First implementation is a light wrapper around HAL    variants/.../*  Variant specific files:  ldscript.ld  for memory layout,  systemclock_config.c  for clock setup, generated by STM32CubeMX,  variant.*  for variant pin layout and pin definitions (pin layout can be copy/pasted from  system/STM32XX/stm32_chip/* ).", 
            "title": "Project structure"
        }, 
        {
            "location": "/about/#general-development-direction", 
            "text": "Self-test code to run on a board to check if the API works for that variant.  Automatic unit test compilation. This ensures that a code change does not break other boards.  Automatic library compilation, to be as arduino-compatible as possible.  Benchmarks to pinpoint bottlenecks.  Hacker-friendly: Enable to use HAL/CMSIS; enable overriding of every IRQ handler.  Add DFU/MSC/HID/MIDI to USB. Rewrite USB to PluggableUSB to be more arduino-compatible.  Create SDIO library  Create I2S library  Create CAN library", 
            "title": "General development direction"
        }
    ]
}